# -*- coding: utf-8 -*-
"""northvolt-case-data-analyst-intern.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JFqiFuyE5YW57yHIFqoT8MM1qFFdVra6
"""

# Imports (add)
import pandas as pd

# Import data into Pandas DataFrame

import pandas as pd
df = pd.read_excel(r'/content/Tesla Battery Survey.xlsx', sheet_name='All entries')

#calulating Cumulated energy use and Equivalent full cycles

df['Cumulated energy use'] = df['Lifetime average [Wh/mi or Wh/km]?']*df['Your range at 100%']
df['EFC'] = df['Mileage [km]']*df['Your range at 100%']

# convert date columns to pd.to_daterime for calculating the difference in days for vehicle age
#What do you observe in this data? Any problems to address? (There were few negative numbers in years which is a data error, the data is in not right format for calculating the days)
df[['Date you charged to 100%','Manufacture date']] = df[['Date you charged to 100%','Manufacture date']].apply(pd.to_datetime) #if conversion required
df["Vehicle age"] = abs(df['Date you charged to 100%'] - df['Manufacture date']).dt.days

#vehicle age in years
df["Vehicle age"]=df["Vehicle age"]/356

#print df

df.head(10)

#For each datapoint, use K column in sheet `Administrative` to assign *usable Wh capacity* for each model/configuration and enhance the dataset (create new column) with this parameter


df1 = pd.read_excel(r'/content/Tesla Battery Survey.xlsx', sheet_name='Administrative')

df1

key = df1[['Unnamed: 5', 'Usable battery capacity when new']]

df1.rename(columns={'Unnamed: 5': 'Vehicle model'}, inplace=True)

df1

key = df1[['Vehicle model', 'Usable battery capacity when new']]

key

#mapping vehicle models with Remaining battery capacity

new = df.merge(
    key,
    on='Vehicle model',
    how='left'
)

new

#How many unique vehicles/users are represented in the dataset?

n = len(pd.unique(new['Vehicle model']))

print("No.of.unique Vehicle models :",
      n)

# What is the count of different reported models (group by Model S/X/3/Other - not detailed configuration)? Example: Model S: 1000, Model X: 1000,  Model 3: 50, Other: 30.

dups = new.pivot_table(columns=['Vehicle model'], aggfunc ='size')

# displaying the duplicate Series
print(dups)

#Create line plot with Relative Range against vehicle age in years (`z_actual` vs `x`) for the vehicle with largest number of datapoints recorded. It should look something like this

filterinfDataframe = new[(new['Username'] == "Benjamin Brooks S85") ]

filterinfDataframe

# Commented out IPython magic to ensure Python compatibility.
# Create line plot with Relative Range against vehicle age in years (`z_actual` vs `x`) for the vehicle with largest number of datapoints recorded. It should look something like this


import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
# % matplotlib inline

sns.set(font_scale=1.4)


filterinfDataframe.set_index('Vehicle age')['Remaining battery capacity'].plot(figsize=(12, 10), linewidth=2.5, color='blue')
plt.xlabel("year", labelpad=15)
plt.ylabel("Normalized Range", labelpad=15)
plt.title("Single User/Vehicle over time", y=1.02, fontsize=22);

# Create scatter plot with Relative Range against vehicle age in years (`z_actual` vs `x`) for all data points (all vehicles). The plot should look something like this

import pandas as pd
import numpy as np



ax1 = new.plot(kind='scatter', x='Vehicle age', y='Remaining battery capacity', color='r')


print(ax1)  # True

#data set for liner regression
LR= new[['Vehicle age','Remaining battery capacity']]

LR = LR.dropna()
print(LR)

#Create a linear model (fit a line) `z = f(x) = A + B*x` (optimize by least square error) to estimate Relative Range from  vehicle age. You are encouraged to make use of existing open source code to help your optimization.

X = LR['Vehicle age'].values.reshape(-1, 1)  # values converts it into a numpy array
Y = LR['Remaining battery capacity'].values.reshape(-1, 1)  # -1 means that calculate the dimension of rows, but have 1 column
  #

# Building the model
X_mean = np.mean(LR['Vehicle age'].values)
Y_mean = np.mean(LR['Remaining battery capacity'].values)

num = 0
den = 0
for i in range(len(X)):
    num += (X[i] - X_mean)*(Y[i] - Y_mean)
    den += (X[i] - X_mean)**2
m = num / den
c = Y_mean - m*X_mean

print (m, c)

# Making predictions and Plot Relative Range model evaluation (`z_pred` vs `x`) in the same figure as corresponding datapoints scatter plot (`z_actual` vs `x`) so that the line goes through the datapoints
Y_pred = m*X + c

plt.scatter(X, Y) # actual

plt.plot([min(X), max(X)], [min(Y_pred), max(Y_pred)], color='red') # predicted
plt.show()

# Plot distribution (histogram plot) of model estimation errors (`z_actual` - `z_pred`)

import matplotlib.pyplot as plt

x = Y- Y_pred
plt.hist(x, bins = 50)
plt.show()

#Calculate standard error (standard deviation) of the Relative Range estimates

# Python code to demonstrate std dev function

np.std(Y_pred, dtype=np.float64)